{"pages":[],"posts":[{"title":"数据结构与算法笔记","text":"数据结构简介笔记内容参考leetcode 数组 链表 栈：先入后出的抽象数据结构，可以使用数组或链表实现 队列：先入先出的抽象数据结构，可以使用链表实现 树 图：分为有向图和无向图 表示图的方法包括：邻接矩阵，邻接表 散列表：散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 key」映射至对应的「值 value」，以实现高效的元素查找。 堆：堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。 动态规划 斐波那契数列：递归法，记忆化递归法，动态规划法 通过让两个整数交替变化 未解决的问题 断点调试程序的方法","link":"/2021/07/08/DataStructure/"},{"title":"happy things","text":"这里用来记录每天遇到的开心的事，即使是一些屁大点的小事2021/08/03最近因为家里总是有小飞虫，所以把房间清扫了一遍。把塑料瓶整理到一个大袋子里，放到了阳台，衣柜和电视柜都把灰扫了出来。而且小虫子有的时候在厕所也有，我已经把厕所刷一遍了，不知道虫子是靠气味还是温度还是光照，昨天晚上想了一个办法就是把台灯搬到厨房，这样可能虫子就不会往屋里面飞了。今天终于下定决心买了妖怪手表4和大表哥2，虽然不知道什么时候有机会开坑，目前硬盘容量有些不太够，我感觉应该要等把神秘海域的坑补上之后再玩大表哥。今天徐静雨有一期视频讲卡特如果死了的话可能会进名人堂，伊戈达拉死了也进不了名人堂，给我笑得肚子疼。 2021/08/04昨天晚上开始看了博伟君的双峰系列视频，一共三季的美剧，含有超自然元素的侦探剧，案件扑朔迷离，时不时来点抽象的惊悚要素，看完之后晚上睡觉的时候一闭眼睛都会不寒而栗。昨天经过精心的筛选，留下了19部个人认为可圈可点的电影，整好控制在了一页之内，完美，还差一部填满一页。最近的游戏开发进度受阻，同时自己又冒出了一些点子，比如去搜索网上的计算机专业的大作业，或者是力扣上面有一些操作系统和计算机网络的课程和练习。 2021/08/09前天周六，g15到货了，比预想中的要重，虽然我比较喜欢这种粗大的外观，但是笔记本的性能确实比较一般，跑分跟上一代的2060笔记本差不多，还有一个问题就是内存只有8G，之前还纠结了一段时间是用8+8还是16+16，不过现在内存都涨价了，打算先等等吧，等到年底再看看。后来下了几个游戏测试，瘟疫传说这个游戏，开高画质基本上显卡占用快满了，显存还是很空闲的，另外cpu一直在25w左右，本来tdp是45w的，但是测试的过程中也没见上去，反倒是显卡最高飙到过90w好像是，笔记本的散热性能也一般吧，如果再加个散热支架，感觉太麻烦了。既然新的笔记本到了，可以慢慢的学一些虚幻4相关的开发。昨天摸了一天的鱼，玩了恐惧之间，闭幕式也没看出什么东西来，另外就是以后应该减少一些坐在床上的时间，对于脊柱的伤害有点大，以后就是尽量睡前或者看电影的时候用mac，平时就尽量坐椅子。今天看lee哥视频里面推荐了一个unity课程，如果后面有时间的话可以尝试报名看看。 2021/08/17时间过得很快，上周给笔记本加了8G内存条，重新跑了一下分，虽然戴尔笔记本比微星的要贵，但是我感觉够用了。装内存条的时候风扇突然转了给我吓一跳，后来在bios设置里改了电池设置，戴尔有一个特性是开盖自动开机让我给关了。周末和王庄联机打了 喋血复仇，我感觉这游戏还算原汁原味吧，但是预购就免了。王庄后来跟我说还预购了暗黑2重制版，我肯定是没时间玩了。之前报的课vipSkill，上完了。最后一节的老师讲了一下入行的事情，妈的讲到12点真能说。感觉国内的游戏公司都是看什么赚钱就做什么游戏，我总觉得这样是和做游戏的初衷背道而驰了。 今天重新回顾这个课程，给我整破防了，因为我之前一直以为很简单的东西，如果不看视频自己直接做的时候我发现自己居然无从下手。比如通过方向键控制3D角色的移动，我草，我自己居然没法正确的用出API函数，逼得我没法了还要回去百度看教程，这明明是最基础的东西。说明我之前两个月的学习实际上效果甚微。是学习方法出了问题。 2021/08/26尝试在新电脑上重新部署hexo，并完成一次提交。接下来回顾一下最近一周发生的事情吧，上周是暑假，最开始的几天疯狂刷C#的网课，后来还搜索了一下unity的学习路线，然后周末迎来了暗黑2重制版的公测，我选的是圣骑士，没想到圣骑士还是亲儿子角色，第一次就瞎玩的和王庄一起打通关了，后来自己有建了一个小号好好玩，带了加掉率的护符，结果第一幕刚打完就神装了。","link":"/2021/08/03/happy-things/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/08/26/hello-world/"},{"title":"game idea","text":"主角试图记住自己的梦境。后来经常在梦里梦到一个女人，并渐渐喜欢上了她。主角其实是患有一种疾病 体内的激素分泌影响到大脑的神经活动，最后男主在手术台最后的梦里可以选择和女主在一起（脑死亡），或者与女主分开（手术成功）。 关于角色的属性设计：智商高，可以完成任何道具的制作但需要花费比较多的时间，口才为零，别人说什么都只会回答 好。","link":"/2021/06/19/game-idea/"},{"title":"How to make a 2D Game","text":"2D Movement in Unity&lt;关于2D碰撞的一些优化设置&gt; Rigidbody2D-Collision Detection Discrete GameObjects with Rigidbody 2Ds and Collider 2Ds can overlap or pass through each other during a physics update Continuous GameObjects with Rigidbody 2Ds and Collider 2Ds do not pass through each other during an update Physics Material 2D Friction Bounciness 12345678910111213141516171819202122// CharacterController2D.csFixedUpdate(){ 判断角色是否落地： 在角色脚下新建一个EmptyObject, 通过Physics2D.OverlapCircleAll方法检测有什么跟角色的脚底发生了碰撞。 如果发生碰撞的不是gameObject, 那么认定角色在地面上。}Move(){ 如果角色在蹲着，判断是否可以站起来： 可以控制player的条件是：player在地面上或者允许player在空中移动 如果player在蹲着，那么降低移动速度}Flip(){ 通过让palyer的localscale的X取负数来实现左右朝向的反转}","link":"/2021/07/02/how-to-make-2D-game/"},{"title":"C#基礎","text":"用于记录C#的基础知识，部分来源于unity官方视频 循环 while(条件){} do{ } while(条件); 语句是先执行再判断，因此程序至少会运行一次。 for(条件){} 常用函数/方法比较 Awake() 即使没有启用脚本也会执行 Start() Update() 每帧调用一次，适用范围：non-physics objects, simple timers, receiving input FixedUpdate() 固定时间调用一次，适用范围：physics (rigidbody) objects， 推荐使用力来定义位移 启动与禁用组件 Component.enabled 平移 transform.Translate(Vector3 是移动的方向) 旋转 transform.Rotate(Vector3 是旋转的轴) 平移和旋转作用于局部轴(local axis)而非世界轴(world axis) GetKey 引用的是按键的固定名字 GetButton 引用的是代表按键的字符串，具体指代哪个按键可以修改 以”Jump”为例 当空格未按下时：GetButtonDown:False GetButton:False GetButtonUp:False 当按下空格时： GetButtonDown:True GetButton:True GetButtonUp:False 按住空格：GetButtonDown:False GetButton:True GetButtonUp:False 松开空格时：GetButtonDown:False GetButton:False GetButtonUp:True 实例 Instantiate, 常用于克隆prefab, 默认返回gameobject类型，也可以通过强制转换成rigidbody来让物体具有物理效果 向量 向量长度：Vector3.magnitude 判断两个向量是否是垂直：点积(dot products) Vector3.Dot(VectorA,VectorB) 求与两个向量垂直的向量：叉积(cross products) Vector3.Cross(VectorA,VectorB) unity采用左手坐标系 类1234567891011121314151617181920212223242526272829303132//Inventory.cs 一个用于管理item的类public class Inventory : MonoBehaviour{ //Stuff是Inventory的子类 public class Stuff { //子类中的变量 public int projectileA; public int projectileB; public int projectileC; public float fuel; //构造函数 public Stuff(int prA, int prB, int prC) { projectileA = prA; projectileB = prB; projectileC = prC; } //构造函数 public Stuff(int prA, float fu) { projectileA = prA; fuel = fu; } //使用构造函数创建类的实例 public Stuff myStuff = new Stuff(1,2,3); public Stuff myOtherStuff = new Stuff(1, 5.0); }} 属性 适用于从类之外的代码访问这个类的成员变量。 属性可以当作变量，也可以封装为成员变量，即字段(field)。 123456789101112131415161718192021222324252627282930313233343536//Player.cs 我们希望能通过其他脚本使用玩家的经验值public class Player{ private int experience; //声明字段(field) //属性的名称推荐以大写字母开头，内部含有set和get两个访问器(accessor) public int Experience { get { //返回所封装的字段，当get不存在时，experience为write only return experience; } set { //通过关键字value给字段赋值，当set不存在时，experience为readonly experience = value; } } public int Level { //使用set访问器启动协同程序？？ get { return experience/1000; } set { experience = value * 1000; } } //简写 public int Health {get; set;}} 1234567891011//Game.cs 通过属性Experience来访问字段experiencepublic class Game : MonoBehaviour{ void Start() { Player myPlayer = new Player(); myPlayer.Experience = 5; int x = myPlayer.Experience; }} 静态 Statics 静态成员，例如变量和方法，是跨类的所有实例共享的成员。 可以直接通过类访问，无需先对类的对象进行实例化。例如Input.GetButton()就是一个静态方法。 通常， 成员变量对于类的每一个对象都是唯一的， 1234567891011121314//Game.cs 在Game类中创建了敌人，并计数public class Game{ void Start() { Enemy enemy1 = new Enemy(); Enemy enemy2 = new Enemy(); Enemy enemy3 = new Enemy(); //统计Enemy类实例化了多少个对象 int x = Enemy.enemyCount; }} 123456789101112//Enemy.cspublic class Enemy{ //enemyCount属于类本身，而不属于任何一个实例 public static int enemyCount = 0; //Enemy类的构造函数，每次调用Enemy类，计数器+1 public Enemy() { enemycount++; }} 方法重载(method overloading) overloading is a process by which you can give a single method multiple definitions. 12345678910111213//SomeClass.cspublic class SomeClass{ public int Add(int num1, int num2) { return num1 + num2; } public string Add(string str1, string str2) { return str1 + str2; }} 泛型(generics) 当不知道对象的类型时，使用泛型，比如GetComponent就是一种泛型方法 1234567891011//SomeClass.cspublic class SomeClass{ //&lt;T&gt;是泛型参数，after the methods name or before the normal parameters //可以代表任意类型 //前面的T叫做方法的返回类型(return type)，后面的T叫做方法的参数类型(arguement type) public T GenericMethod&lt;T&gt;(T param) { return param; }} 12345678910//SomeOtherClass.cs 用于使用上面创建的泛型方法public class SomeOtherClass : MonoBehaviour{ void Start() { SomeClass myClass = new SomeClass(); myClass.GenericMethod&lt;int&gt;(5); }} 1234567891011//GenericClass.cs this class uses a generic type of Tpublic class GenericClass&lt;T&gt;{ //类型为T的成员变量 T item; // public void UpdateItem(T newItem) { item = newItem; }} 12345678910//GenericClassExample.cs 实例化上面的类public class GenericClassExample : MonoBehaviour{ void Start() { //为T指定一个类型并实例化 GenericClass&lt;int&gt; myClass = new GenericClass&lt;int&gt;(); myClass.UpdateItem(5); }} 列表 列表List类似一个动态数组，也是一个泛型类。 12345678910111213141516171819//创建一个名为ages的List，当按空格时随机生成一个年龄，当按Q时随机删除一个public class ListExample : MonoBehaviour{ public List&lt;int&gt; ages = new List&lt;int&gt;(); void Update() { if(Input.GetKeyDown(KeyCode.Space)) { ages.Add(Random.Range(1,100)); } if(Input.GetKeyDown(KeyCode.Q)) { ages.Remove(Random.Range(1,ages.Count)); } }} 继承(inheritance) 通常看到的 public class Player : MonoBehaviour {} 表示MonoBehaviour是Player的父类 多态(polymorphism) 接口(interface) 接口的好处在于可以跨越不同的类去定义通用的功能 1234567//damageInterface.cs//接口名通常以大写字母I开头，后面的单词表示能做什么public interface IDamageable{ void Damage(); //接口内部只负责声明方法，变量} 12345678// wall.cspublic wall : MonoBehaviour, IDamageable{ public void Damage() { }} 12345678//car.cspublic car : MonoBehaviour, IDamageable{ public void Damage() { }} 协同程序(coroutines) 协同程序可视为按时间间隔执行的程序，好处是可以实现update()函数的功能，提高代码的效率 12// 四元数(quaternion) in Unity, a transforms rotation is stored as a quaternion. 委托(delegates) 一个委托可以代表多个方法，好处是方便在游戏中动态控制需要调用哪些函数，或者是同时调用多个函数 123456789101112131415161718192021222324252627//MulticaseScript.cspublic class MulticastScript : MonoBheaviour{ delegate void MultiDelegate(); //创建委托类型 MultiDelegate myMultiDelegate; //声明成员变量 void start() { myMultiDelegate += PowerUp; myMultiDelegate += TurnRed; if(myMultiDelegate != null) { myMultiDelegate(); //此时这里同时调用两个函数 } } void PowerUp() { print(&quot;aaaaaaaaaaaa&quot;); } void TurnRed() { GetComponent&lt;Renderer&gt;().material.color = Color.red; }} 事件 事件属于一种特殊的委托， 12345678910111213141516//EventManager.cs 这个例子的脚本挂载到主相机上public class EventManager : MonoBheaviour{ public delegate void ClickAction(); public static event ClickAction OnClicked; //创建事件变量 void OnGUI() { if() //当在游戏画面中点击按钮的时候调用这个事件 { if(OnClicked != null) OnClicked(); } }} 12345678910111213141516//ObjectA.cs 脚本挂载到物体A上public class ObjectA : MonoBheaviour{ void OnEable() { EventManager.OnClicked += MethodName; //当事件触发时，调用订阅了这个事件的方法 } void OnDisable() { EventManager.OnClicked -= MethodName; //退订，防止内存泄漏 } void MethodName() {}} 补充技巧 用于调试程序 Debug.Log( ); 绘制项目中的对象 OnDrawGizmos() {定义颜色和要绘制的对象} 测试游戏运行时的性能影响 profiler工具 代码规范 Uinty Documentation Scipting API 如何查看官方文档，这里以GameObject为例： Inherits from:Object (继承自Object) Description:Base class for all entities in Unity Scenes. Properties: transform:(通过gameObject.transform来访问，并能看到这属性是只读的。这里的gameObject相当于是GameObject的一个实例。或者直接用transform来访问。区别是什么不知道) Public Methods: SetActive:(通过gameObject.SetActive()来调用这个方法) Static Methods: Find:(通过GameObject.Find()来调用这个方法) Inherited Members 继承自Object的一些东西 Properties: name:(通过gameObject.name或者name来访问) Public Methods: ToString:(通过gameObject.ToString()或者ToString()来调用方法) Static Methods: Destory:(通过Destroy()或者Object.Destroy()或者GameObject.Destroy()来调用方法。) 总结：对于Properties和Public Methods，先实例化类，再通过实例去调用和访问。对于Static Methods无须实例化，因此可以以类的名字.方法名字去调用。 相关频道推荐 Brackeys: GameDevHQ/Jonathan: C#初中高级教程 Sebastian Lague： 涉及的范围很广，需要一定基础 还未解决的问题 类中的静态变量和字段都可以用于在外面访问，有什么区别？ 序列化 [SerializeField] 好像是把成员变量进行存贮的方法，在加载脚本的时候变量的值会自动被赋值","link":"/2021/07/01/C-%E5%9F%BA%E7%A1%80/"},{"title":"latex写论文时的技巧总结","text":"1.插入表格的注意事项一般插入的表格是单栏的，也就是说只能显示在左边或者右边 1\\begin {table}...\\end {table} 如果表格的字比较多，或者横轴的项目比较多，希望表格能够横跨两栏 1\\begin {table*}...\\end {table*}","link":"/2021/06/19/latex%E5%86%99%E8%AE%BA%E6%96%87%E6%97%B6%E7%9A%84%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"title":"markdown的语法使用的一些注意点","text":"关于插入代码，其中一种方法是123```(用的是什么编程语言，可写可不写)代码正文```三个点结束，后面不能加空格，否则在浏览器上显示的时候会和后面的格式冲突","link":"/2021/06/02/markdown%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9/"},{"title":"Unity_2D_Jump","text":"JUMP关于用unity开发2D跳跃游戏的一些思路 Case 01:12345678910111213141516171819202122232425262728293031//跳跃最基础的实现方法：当空格按下时，给刚体一个向上的力//缺陷：连按空格人会一直向上，下落的时候看起来人是飘飘的public class Jump : MonoBehaviour{ public float jumpForce = 5f; private Rigidbody2D _rigidbody2D; private bool jumpRequest; void Start() { _rigidbody2D = GetComponent&lt;Rigidbody2D&gt;(); } private void Update() { if(Input.GetButtonDown(&quot;Jump&quot;)) { jumpRequest = true; } } private void FixedUpdate() { if(jumpRequest) { //ForceMode2D.Impulse _rigidbody2D.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse); jumpRequest = false; } }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//改进：点按和长按空格，起跳的速度不一样//通过刚体当前的速度来判断是在上升还是在下落，给刚体不同的重力大小public class JumpTest : MonoBehaviour{ public float jumpForce = 5f; public float fallMultiplier = 2.5f; public float lowJumpMultiplier = 2f; private Rigidbody2D _rigidbody2D; private bool jumpRequest; void Start() { _rigidbody2D = GetComponent&lt;Rigidbody2D&gt;(); } private void Update() { if(Input.GetButtonDown(&quot;Jump&quot;)) { jumpRequest = true; } } private void FixedUpdate() { if(jumpRequest) { _rigidbody2D.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse); jumpRequest = false; } //当刚体在下落时 if (_rigidbody2D.velocity.y &lt; 0) { _rigidbody2D.gravityScale = fallMultiplier; } //当刚体在上升时，且空格不是按下的状态 else if (_rigidbody2D.velocity.y &gt; 0 &amp;&amp; !Input.GetButton(&quot;Jump&quot;)) { _rigidbody2D.gravityScale = lowJumpMultiplier; } else { _rigidbody2D.gravityScale = 1f; } }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//改进：增加角色与环境的碰撞检测，解决角色可以在空中无限跳跃的问题public class JumpBox : MonoBehaviour{ [Range(0, 10)] public float jumpForce = 5f; public LayerMask mask; public float boxHeight = 0.5f; private Vector2 playerSize; private Vector2 boxSize; private bool jumpRequest = false; private bool grounded = false; public float fallMultiplier = 2.5f; public float lowJumpMultiplier = 2f; private Rigidbody2D _rigidbody2D; void Start() { _rigidbody2D = GetComponent&lt;Rigidbody2D&gt;(); playerSize = GetComponent&lt;SpriteRenderer&gt;().bounds.size; boxSize = new Vector2(playerSize.x * 0.5f, boxHeight); } void Update() { //当角色在地面按下空格时 if (Input.GetButtonDown(&quot;Jump&quot;) &amp;&amp; grounded) { jumpRequest = true; } } private void FixedUpdate() { if (jumpRequest) { _rigidbody2D.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse); jumpRequest = false; grounded = false; } //否则，为了让角色在其他情况下按空格都不会跳起来，需要检测角色是否在地面上 else { //检测盒子的中心是角色的脚底 Vector2 boxCenter = (Vector2)transform.position + (Vector2.down * playerSize * 0.5f); // if (Physics2D.OverlapBox(boxCenter, boxSize, 0, mask) != null) { grounded = true; } else { grounded = false; } } if (_rigidbody2D.velocity.y &lt; 0) { _rigidbody2D.gravityScale = fallMultiplier; } else if (_rigidbody2D.velocity.y &gt; 0 &amp;&amp; !Input.GetButton(&quot;Jump&quot;)) { _rigidbody2D.gravityScale = lowJumpMultiplier; } else { _rigidbody2D.gravityScale = 1f; } }}","link":"/2021/07/02/unity-2D-jump/"},{"title":"unity官方教程ruby","text":"这篇博客主要用于记录官方的入门教程ruby’s advanture 1.导入主角ruby导入后需要把主角名字改为player,因此tag也是player。添加刚体组件rigidbody 2D，由于是在2D环境下开发，因此重力gravity是0，为了避免因为碰撞而在Z轴上发生旋转，因此勾选freeze rotation。添加自定义组件PlayerController，编写脚本使player能够上下左右移动。 为player制作等待动画idle animation，包括四个方向，其中左右通过flip属性来完成镜像。在animation/player中自定义一个blend tree,目的是为了混合四个方向的动画。 2.绘制场景","link":"/2021/06/14/unity-learn-ruby/"},{"title":"Unity_Timeline","text":"2021.063D基础：Roll a Ball (siki学院) 2D案例：坦克大战 (siki学院)，Ruby’s Adventure(unity官方), Pixel Adventure(像素忍者) 2021.07How to make a 2D Game (Brackeys) C# Intermediate Unity Tutorials (GameDevHQ) √ C# 中级教程 (Unity官方) 2D Game Kit (Unity Asset Store) (玩了一遍) 图解算法数据结构(leetcode) 初级算法(leetcode) 先比较两边的代码，然后进行移植(2d movement/animator √) How to make a Tower Defense Game (Brackeys 01-12) 2021.08How to make a Tower Defense Game (Brackeys 13-23) 找一些中级C#教程看 找一些中型项目的教程 从8月开始，不再是跟着视频手把手的做，尽量做到看一遍视频，然后自己遍动脑，独立完成。 C语言写的学生管理系统。 遇到的问题How to make a Tower Defense Game (E08 SHOP) 1：19 关于pixel perfect的用法","link":"/2021/07/02/unity-study-timeline/"},{"title":"unity学习笔记01","text":"内容整理参考B站UP主 yu_zhen基本介绍新建的项目默认包括一个主相机和一个光源 在空白处右键添加新的元素：3D Object-Terrain 是地形，在Scene中显示为一个平面3D Object-Tube 是立方体Creat Empty是空对象，我感觉类似编程思想中的object 看官方文档没搞懂的地方：游戏对象的可拾取性（在hierarchy窗口中）正交视图是干什么用的（一般情况下用的都是Perspective透视视图）pivot和center的关系:https://blog.csdn.net/weixin_41319239/article/details/93681860烘培光照贴图是什么意思：https://docs.unity.cn/cn/2020.3/Manual/MultiSceneEditing.html多场景编辑有什么用关于2D关节组件Joint2D，2D效应器组件Effector2D的应用案例在3DObject中有一个布娃娃Ragdoll","link":"/2021/06/02/unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"},{"title":"做过的梦","text":"1.杀人事件 20210619我，子城，张哲，周宇去给一个小女孩过生日。最后我们五个人要开车离开，开车到一半的时候，有人说忘了东西要回去一趟，于是我们都跟着回去了，下车后女孩跑进了教堂，我和子城追了过去，教堂左边右边都是双层的大走廊，我和子城去了左边找小女孩，张哲和周宇去了右边。后来周宇在右边的二楼发现了小女孩的尸体，胸口被贯穿，当时貌似只有张哲不在场，因此我一直怀疑张哲。不过警察却认为这是一场意外。后面的内容记不清了。 2.郑娥事件 20210621某个不露脸的主播在一次直播中与一名黑丝女子xxoo，期间被观众捕捉到了男主播的正脸和女子的名字叫郑娥。很快有记者把这个名字锁定在了一家妇科医院。记者通过看病为由进入医院和郑娥见面并确定了就是此人。随后记者在她下班后一路尾随到了她家。连门牌号都确定了，却不明白为什么跟踪的过程为什么这么顺利。他们后来调查了解到郑娥因为行为不检点，经常利用职务之便给自己做堕胎手术，先前提到的主播也只不过是她的众多炮友中的一个。","link":"/2021/06/19/%E5%81%9A%E8%BF%87%E7%9A%84%E6%A2%A6/"},{"title":"用hexo搭建个人博客的过程记录","text":"这是第一篇博客，主要记录用hexo搭建的过程和熟悉markdown的语法 1.包的安装和初始化 安装node.js 通过cmd打开windows的终端安装镜像包和hexo包 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org $ cnpm install -g hexo-cli 在C盘下新建文件夹hexo_blog/ 回到终端初始化博客 1$ hexo init 至此windows终端上的操作结束，博客文章默认保存在hexo_blog/source/_posts在里面也可以看到自带的hello-world.md 2.部署远端仓库 在github中新建仓库名qifeng1994.github.io 在git bash中安装hexo插件 1$ cnpm install --save hexo-deployer-git 用编辑器打开hexo_blog/_config.yml在 # Deployment 的下面修改1234deploy:type: gitrepo: https://github.com/qifeng1994/qifeng1994.github.io.gitbranch: master 回到git bash在hexo_blog/ 把本地仓库部署到github上1$ hexo d 3.额外的修改 为了解决插入图片后不显示的问题： 修改_config.yml中设置 1234post_asset_folder: true # URL url: https://qifeng1994.github.io 安装hexo额外的图片路径转换插件1$ cnpm install hexo-asset-image –save 修改代码/node_modules/hexo-asset-image/index.js 4.尝试写第一篇博客 新建一篇博客 1$ hexo n &quot;文件名&quot; 注意这里的文件名就是md的文件名，而这篇博客具体的标题可以在md里面修改，在hexo_blog/source/_posts下生成了同名的文件夹用于存放图片 由于安装了插件，插入图片时不采用md的语法1{% asset_img man.png 图片的说明 %} 在本地写好博客之后，可以先在本地浏览器预览1$ hexo s 生成静态文件1$ hexo g 部署到远端1$ hexo d 最下面是一个插入图片的例子 目前写markdown存在的问题 带后缀的句子会被识别为超链接 如何让插入的图片靠左边显示 目前遇到的坑 插入图片的时候后缀是大小写敏感的，比如，如果一个图片叫man.PNG，那么你插入的时候如果用 1{% asset_img man.png %} 就会显示不出来 hexo d 部署后个人主页404的原因 我之前把仓库的权限改成了privite,后来发现有一种说法是github如果想做个人主页的话，仓库必须要是public才行，然后尝试重新部署即可：hexo clean, hexo g, hexo d","link":"/2021/08/26/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"}],"tags":[],"categories":[]}