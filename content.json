{"pages":[],"posts":[{"title":"C#基礎","text":"用于记录C#的基础知识，部分来源于unity官方视频 循环 while(条件){} do{ } while(条件); 语句是先执行再判断，因此程序至少会运行一次。 for(条件){} 常用函数/方法比较 Awake() 即使没有启用脚本也会执行 Start() Update() 每帧调用一次，适用范围：non-physics objects, simple timers, receiving input FixedUpdate() 固定时间调用一次，适用范围：physics (rigidbody) objects， 推荐使用力来定义位移 启动与禁用组件 Component.enabled 平移 transform.Translate(Vector3 是移动的方向) 旋转 transform.Rotate(Vector3 是旋转的轴) 平移和旋转作用于局部轴(local axis)而非世界轴(world axis) GetKey 引用的是按键的固定名字 GetButton 引用的是代表按键的字符串，具体指代哪个按键可以修改 以”Jump”为例 当空格未按下时：GetButtonDown:False GetButton:False GetButtonUp:False 当按下空格时： GetButtonDown:True GetButton:True GetButtonUp:False 按住空格：GetButtonDown:False GetButton:True GetButtonUp:False 松开空格时：GetButtonDown:False GetButton:False GetButtonUp:True 实例 Instantiate, 常用于克隆prefab, 默认返回gameobject类型，也可以通过强制转换成rigidbody来让物体具有物理效果 向量 向量长度：Vector3.magnitude 判断两个向量是否是垂直：点积(dot products) Vector3.Dot(VectorA,VectorB) 求与两个向量垂直的向量：叉积(cross products) Vector3.Cross(VectorA,VectorB) unity采用左手坐标系 类 1234567891011121314151617181920212223242526272829303132//Inventory.cs 一个用于管理item的类public class Inventory : MonoBehaviour{ //Stuff是Inventory的子类 public class Stuff { //子类中的变量 public int projectileA; public int projectileB; public int projectileC; public float fuel; //构造函数 public Stuff(int prA, int prB, int prC) { projectileA = prA; projectileB = prB; projectileC = prC; } //构造函数 public Stuff(int prA, float fu) { projectileA = prA; fuel = fu; } //使用构造函数创建类的实例 public Stuff myStuff = new Stuff(1,2,3); public Stuff myOtherStuff = new Stuff(1, 5.0); }} 属性 适用于从类之外的代码访问这个类的成员变量。 属性可以当作变量，也可以封装为成员变量，即字段(field)。 123456789101112131415161718192021222324252627282930313233343536//Player.cs 我们希望能通过其他脚本使用玩家的经验值public class Player{ private int experience; //声明字段(field) //属性的名称推荐以大写字母开头，内部含有set和get两个访问器(accessor) public int Experience { get { //返回所封装的字段，当get不存在时，experience为write only return experience; } set { //通过关键字value给字段赋值，当set不存在时，experience为readonly experience = value; } } public int Level { //使用set访问器启动协同程序？？ get { return experience/1000; } set { experience = value * 1000; } } //简写 public int Health {get; set;}} 1234567891011//Game.cs 通过属性Experience来访问字段experiencepublic class Game : MonoBehaviour{ void Start() { Player myPlayer = new Player(); myPlayer.Experience = 5; int x = myPlayer.Experience; }} 静态 Statics 静态成员，例如变量和方法，是跨类的所有实例共享的成员。 可以直接通过类访问，无需先对类的对象进行实例化。例如Input.GetButton()就是一个静态方法。 通常， 成员变量对于类的每一个对象都是唯一的， 1234567891011121314//Game.cs 在Game类中创建了敌人，并计数public class Game{ void Start() { Enemy enemy1 = new Enemy(); Enemy enemy2 = new Enemy(); Enemy enemy3 = new Enemy(); //统计Enemy类实例化了多少个对象 int x = Enemy.enemyCount; }} 123456789101112//Enemy.cspublic class Enemy{ //enemyCount属于类本身，而不属于任何一个实例 public static int enemyCount = 0; //Enemy类的构造函数，每次调用Enemy类，计数器+1 public Enemy() { enemycount++; }} 方法重载(method overloading) overloading is a process by which you can give a single method multiple definitions. 12345678910111213//SomeClass.cspublic class SomeClass{ public int Add(int num1, int num2) { return num1 + num2; } public string Add(string str1, string str2) { return str1 + str2; }} 泛型(generics) 当不知道对象的类型时，使用泛型，比如GetComponent就是一种泛型方法 1234567891011//SomeClass.cspublic class SomeClass{ //&lt;T&gt;是泛型参数，after the methods name or before the normal parameters //可以代表任意类型 //前面的T叫做方法的返回类型(return type)，后面的T叫做方法的参数类型(arguement type) public T GenericMethod&lt;T&gt;(T param) { return param; }} 12345678910//SomeOtherClass.cs 用于使用上面创建的泛型方法public class SomeOtherClass : MonoBehaviour{ void Start() { SomeClass myClass = new SomeClass(); myClass.GenericMethod&lt;int&gt;(5); }} 1234567891011//GenericClass.cs this class uses a generic type of Tpublic class GenericClass&lt;T&gt;{ //类型为T的成员变量 T item; // public void UpdateItem(T newItem) { item = newItem; }} 12345678910//GenericClassExample.cs 实例化上面的类public class GenericClassExample : MonoBehaviour{ void Start() { //为T指定一个类型并实例化 GenericClass&lt;int&gt; myClass = new GenericClass&lt;int&gt;(); myClass.UpdateItem(5); }} 列表 列表List类似一个动态数组，也是一个泛型类。 12345678910111213141516171819//创建一个名为ages的List，当按空格时随机生成一个年龄，当按Q时随机删除一个public class ListExample : MonoBehaviour{ public List&lt;int&gt; ages = new List&lt;int&gt;(); void Update() { if(Input.GetKeyDown(KeyCode.Space)) { ages.Add(Random.Range(1,100)); } if(Input.GetKeyDown(KeyCode.Q)) { ages.Remove(Random.Range(1,ages.Count)); } }} 继承(inheritance) 通常看到的 public class Player : MonoBehaviour {} 表示MonoBehaviour是Player的父类 多态(polymorphism) 接口(interface) 接口的好处在于可以跨越不同的类去定义通用的功能 1234567//damageInterface.cs//接口名通常以大写字母I开头，后面的单词表示能做什么public interface IDamageable{ void Damage(); //接口内部只负责声明方法，变量} 12345678// wall.cspublic wall : MonoBehaviour, IDamageable{ public void Damage() { }} 12345678//car.cspublic car : MonoBehaviour, IDamageable{ public void Damage() { }} 协同程序(coroutines) 协同程序可视为按时间间隔执行的程序，好处是可以实现update()函数的功能，提高代码的效率 12// 四元数(quaternion) in Unity, a transforms rotation is stored as a quaternion. 委托(delegates) 一个委托可以代表多个方法，好处是方便在游戏中动态控制需要调用哪些函数，或者是同时调用多个函数 123456789101112131415161718192021222324252627//MulticaseScript.cspublic class MulticastScript : MonoBheaviour{ delegate void MultiDelegate(); //创建委托类型 MultiDelegate myMultiDelegate; //声明成员变量 void start() { myMultiDelegate += PowerUp; myMultiDelegate += TurnRed; if(myMultiDelegate != null) { myMultiDelegate(); //此时这里同时调用两个函数 } } void PowerUp() { print(&quot;aaaaaaaaaaaa&quot;); } void TurnRed() { GetComponent&lt;Renderer&gt;().material.color = Color.red; }} 事件 事件属于一种特殊的委托， 12345678910111213141516//EventManager.cs 这个例子的脚本挂载到主相机上public class EventManager : MonoBheaviour{ public delegate void ClickAction(); public static event ClickAction OnClicked; //创建事件变量 void OnGUI() { if() //当在游戏画面中点击按钮的时候调用这个事件 { if(OnClicked != null) OnClicked(); } }} 12345678910111213141516//ObjectA.cs 脚本挂载到物体A上public class ObjectA : MonoBheaviour{ void OnEable() { EventManager.OnClicked += MethodName; //当事件触发时，调用订阅了这个事件的方法 } void OnDisable() { EventManager.OnClicked -= MethodName; //退订，防止内存泄漏 } void MethodName() {}} 补充技巧 用于调试程序 Debug.Log( ); 绘制项目中的对象 OnDrawGizmos() {定义颜色和要绘制的对象} 测试游戏运行时的性能影响 profiler工具 代码规范 Uinty Documentation Scipting API 如何查看官方文档，这里以GameObject为例： Inherits from:Object (继承自Object) Description:Base class for all entities in Unity Scenes. Properties: transform:(通过gameObject.transform来访问，并能看到这属性是只读的。这里的gameObject相当于是GameObject的一个实例。或者直接用transform来访问。区别是什么不知道) Public Methods: SetActive:(通过gameObject.SetActive()来调用这个方法) Static Methods: Find:(通过GameObject.Find()来调用这个方法) Inherited Members 继承自Object的一些东西 Properties: name:(通过gameObject.name或者name来访问) Public Methods: ToString:(通过gameObject.ToString()或者ToString()来调用方法) Static Methods: Destory:(通过Destroy()或者Object.Destroy()或者GameObject.Destroy()来调用方法。) 总结：对于Properties和Public Methods，先实例化类，再通过实例去调用和访问。对于Static Methods无须实例化，因此可以以类的名字.方法名字去调用。 相关频道推荐 Brackeys: GameDevHQ/Jonathan: C#初中高级教程 Sebastian Lague： 涉及的范围很广，需要一定基础 还未解决的问题 类中的静态变量和字段都可以用于在外面访问，有什么区别？ 序列化 [SerializeField] 好像是把成员变量进行存贮的方法，在加载脚本的时候变量的值会自动被赋值","link":"/2021/07/01/C-%E5%9F%BA%E7%A1%80/"},{"title":"数据结构与算法笔记","text":"数据结构简介笔记内容参考leetcode 数组 链表 栈：先入后出的抽象数据结构，可以使用数组或链表实现 队列：先入先出的抽象数据结构，可以使用链表实现 树 图：分为有向图和无向图 表示图的方法包括：邻接矩阵，邻接表 散列表：散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 key」映射至对应的「值 value」，以实现高效的元素查找。 堆：堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。 动态规划 斐波那契数列：递归法，记忆化递归法，动态规划法 通过让两个整数交替变化 2. 未解决的问题 断点调试程序的方法","link":"/2021/07/08/DataStructure/"},{"title":"cpp","text":"CPP相关Blueprint with C++C++vector source code123456789101112131415161718192021222324252627282930313233343536//MSVC\\14.29\\include\\vectornamespace std{ // CLASS TEMPLATE _Vector_const_iterator template&lt;class _Myvec&gt; class _Vector_const_iterator {//这里面写了很多迭代器操作符的重载}; // CLASS TEMPLATE _Vector_iterator template &lt;class _Myvec&gt; class _Vector_iterator : public _Vector_const_iterator&lt;_Myvec&gt;{}； // CLASS TEMPLATE _Vector_val template &lt;class _Val_types&gt; class _Vector_val{}; // CLASS TEMPLATE vector template &lt;class _Ty, class _Alloc = allocator&lt;_Ty&gt;&gt; class vector { //构造函数 //成员函数 push_back,insert,assign,resize... }; template &lt;class _Ret&gt; struct _Vbase_compare_three_way{}; // CLASS TEMPLATE _Vb_val template &lt;class _Alloc&gt; class _Vb_val{}; // CLASS vector&lt;bool&gt; template &lt;class _Alloc&gt; : public _Vb_val&lt;_Alloc&gt; class vector&lt;bool, _Alloc&gt;{};} 插入图片测试","link":"/2022/06/07/cpp/"},{"title":"game idea","text":"主角试图记住自己的梦境。后来经常在梦里梦到一个女人，并渐渐喜欢上了她。主角其实是患有一种疾病 体内的激素分泌影响到大脑的神经活动，最后男主在手术台最后的梦里可以选择和女主在一起（脑死亡），或者与女主分开（手术成功）。 关于角色的属性设计：智商高，可以完成任何道具的制作但需要花费比较多的时间，口才为零，别人说什么都只会回答 好。","link":"/2021/06/19/game-idea/"},{"title":"happy things","text":"这里用来记录每天遇到的开心的事，即使是一些屁大点的小事2021/08/03最近因为家里总是有小飞虫，所以把房间清扫了一遍。把塑料瓶整理到一个大袋子里，放到了阳台，衣柜和电视柜都把灰扫了出来。而且小虫子有的时候在厕所也有，我已经把厕所刷一遍了，不知道虫子是靠气味还是温度还是光照，昨天晚上想了一个办法就是把台灯搬到厨房，这样可能虫子就不会往屋里面飞了。今天终于下定决心买了妖怪手表4和大表哥2，虽然不知道什么时候有机会开坑，目前硬盘容量有些不太够，我感觉应该要等把神秘海域的坑补上之后再玩大表哥。今天徐静雨有一期视频讲卡特如果死了的话可能会进名人堂，伊戈达拉死了也进不了名人堂，给我笑得肚子疼。 2021/08/04昨天晚上开始看了博伟君的双峰系列视频，一共三季的美剧，含有超自然元素的侦探剧，案件扑朔迷离，时不时来点抽象的惊悚要素，看完之后晚上睡觉的时候一闭眼睛都会不寒而栗。昨天经过精心的筛选，留下了19部个人认为可圈可点的电影，整好控制在了一页之内，完美，还差一部填满一页。最近的游戏开发进度受阻，同时自己又冒出了一些点子，比如去搜索网上的计算机专业的大作业，或者是力扣上面有一些操作系统和计算机网络的课程和练习。 2021/08/09前天周六，g15到货了，比预想中的要重，虽然我比较喜欢这种粗大的外观，但是笔记本的性能确实比较一般，跑分跟上一代的2060笔记本差不多，还有一个问题就是内存只有8G，之前还纠结了一段时间是用8+8还是16+16，不过现在内存都涨价了，打算先等等吧，等到年底再看看。后来下了几个游戏测试，瘟疫传说这个游戏，开高画质基本上显卡占用快满了，显存还是很空闲的，另外cpu一直在25w左右，本来tdp是45w的，但是测试的过程中也没见上去，反倒是显卡最高飙到过90w好像是，笔记本的散热性能也一般吧，如果再加个散热支架，感觉太麻烦了。既然新的笔记本到了，可以慢慢的学一些虚幻4相关的开发。昨天摸了一天的鱼，玩了恐惧之间，闭幕式也没看出什么东西来，另外就是以后应该减少一些坐在床上的时间，对于脊柱的伤害有点大，以后就是尽量睡前或者看电影的时候用mac，平时就尽量坐椅子。今天看lee哥视频里面推荐了一个unity课程，如果后面有时间的话可以尝试报名看看。 2021/08/17时间过得很快，上周给笔记本加了8G内存条，重新跑了一下分，虽然戴尔笔记本比微星的要贵，但是我感觉够用了。装内存条的时候风扇突然转了给我吓一跳，后来在bios设置里改了电池设置，戴尔有一个特性是开盖自动开机让我给关了。周末和王庄联机打了 喋血复仇，我感觉这游戏还算原汁原味吧，但是预购就免了。王庄后来跟我说还预购了暗黑2重制版，我肯定是没时间玩了。之前报的课vipSkill，上完了。最后一节的老师讲了一下入行的事情，妈的讲到12点真能说。感觉国内的游戏公司都是看什么赚钱就做什么游戏，我总觉得这样是和做游戏的初衷背道而驰了。 今天重新回顾这个课程，给我整破防了，因为我之前一直以为很简单的东西，如果不看视频自己直接做的时候我发现自己居然无从下手。比如通过方向键控制3D角色的移动，我草，我自己居然没法正确的用出API函数，逼得我没法了还要回去百度看教程，这明明是最基础的东西。说明我之前两个月的学习实际上效果甚微。是学习方法出了问题。 2021/08/26尝试在新电脑上重新部署hexo，并完成一次提交。接下来回顾一下最近一周发生的事情吧，上周是暑假，最开始的几天疯狂刷C#的网课，后来还搜索了一下unity的学习路线，然后周末迎来了暗黑2重制版的公测，我选的是圣骑士，没想到圣骑士还是亲儿子角色，第一次就瞎玩的和王庄一起打通关了，后来自己有建了一个小号好好玩，带了加掉率的护符，结果第一幕刚打完就神装了。","link":"/2021/08/03/happy-things/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/08/26/hello-world/"},{"title":"latex写论文时的技巧总结","text":"1.插入表格的注意事项一般插入的表格是单栏的，也就是说只能显示在左边或者右边 1\\begin {table}...\\end {table} 如果表格的字比较多，或者横轴的项目比较多，希望表格能够横跨两栏 1\\begin {table*}...\\end {table*}","link":"/2021/06/19/latex%E5%86%99%E8%AE%BA%E6%96%87%E6%97%B6%E7%9A%84%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"title":"markdown的语法使用的一些注意点","text":"关于插入代码，其中一种方法是123```(用的是什么编程语言，可写可不写)代码正文```三个点结束，后面不能加空格，否则在浏览器上显示的时候会和后面的格式冲突","link":"/2021/06/02/markdown%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9/"},{"title":"Unity_2D_Jump","text":"JUMP关于用unity开发2D跳跃游戏的一些思路 Case 01:12345678910111213141516171819202122232425262728293031//跳跃最基础的实现方法：当空格按下时，给刚体一个向上的力//缺陷：连按空格人会一直向上，下落的时候看起来人是飘飘的public class Jump : MonoBehaviour{ public float jumpForce = 5f; private Rigidbody2D _rigidbody2D; private bool jumpRequest; void Start() { _rigidbody2D = GetComponent&lt;Rigidbody2D&gt;(); } private void Update() { if(Input.GetButtonDown(&quot;Jump&quot;)) { jumpRequest = true; } } private void FixedUpdate() { if(jumpRequest) { //ForceMode2D.Impulse _rigidbody2D.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse); jumpRequest = false; } }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//改进：点按和长按空格，起跳的速度不一样//通过刚体当前的速度来判断是在上升还是在下落，给刚体不同的重力大小public class JumpTest : MonoBehaviour{ public float jumpForce = 5f; public float fallMultiplier = 2.5f; public float lowJumpMultiplier = 2f; private Rigidbody2D _rigidbody2D; private bool jumpRequest; void Start() { _rigidbody2D = GetComponent&lt;Rigidbody2D&gt;(); } private void Update() { if(Input.GetButtonDown(&quot;Jump&quot;)) { jumpRequest = true; } } private void FixedUpdate() { if(jumpRequest) { _rigidbody2D.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse); jumpRequest = false; } //当刚体在下落时 if (_rigidbody2D.velocity.y &lt; 0) { _rigidbody2D.gravityScale = fallMultiplier; } //当刚体在上升时，且空格不是按下的状态 else if (_rigidbody2D.velocity.y &gt; 0 &amp;&amp; !Input.GetButton(&quot;Jump&quot;)) { _rigidbody2D.gravityScale = lowJumpMultiplier; } else { _rigidbody2D.gravityScale = 1f; } }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//改进：增加角色与环境的碰撞检测，解决角色可以在空中无限跳跃的问题public class JumpBox : MonoBehaviour{ [Range(0, 10)] public float jumpForce = 5f; public LayerMask mask; public float boxHeight = 0.5f; private Vector2 playerSize; private Vector2 boxSize; private bool jumpRequest = false; private bool grounded = false; public float fallMultiplier = 2.5f; public float lowJumpMultiplier = 2f; private Rigidbody2D _rigidbody2D; void Start() { _rigidbody2D = GetComponent&lt;Rigidbody2D&gt;(); playerSize = GetComponent&lt;SpriteRenderer&gt;().bounds.size; boxSize = new Vector2(playerSize.x * 0.5f, boxHeight); } void Update() { //当角色在地面按下空格时 if (Input.GetButtonDown(&quot;Jump&quot;) &amp;&amp; grounded) { jumpRequest = true; } } private void FixedUpdate() { if (jumpRequest) { _rigidbody2D.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse); jumpRequest = false; grounded = false; } //否则，为了让角色在其他情况下按空格都不会跳起来，需要检测角色是否在地面上 else { //检测盒子的中心是角色的脚底 Vector2 boxCenter = (Vector2)transform.position + (Vector2.down * playerSize * 0.5f); // if (Physics2D.OverlapBox(boxCenter, boxSize, 0, mask) != null) { grounded = true; } else { grounded = false; } } if (_rigidbody2D.velocity.y &lt; 0) { _rigidbody2D.gravityScale = fallMultiplier; } else if (_rigidbody2D.velocity.y &gt; 0 &amp;&amp; !Input.GetButton(&quot;Jump&quot;)) { _rigidbody2D.gravityScale = lowJumpMultiplier; } else { _rigidbody2D.gravityScale = 1f; } }}","link":"/2021/07/02/unity-2D-jump/"},{"title":"unity官方教程ruby","text":"这篇博客主要用于记录官方的入门教程ruby’s advanture 1.导入主角ruby导入后需要把主角名字改为player,因此tag也是player。添加刚体组件rigidbody 2D，由于是在2D环境下开发，因此重力gravity是0，为了避免因为碰撞而在Z轴上发生旋转，因此勾选freeze rotation。添加自定义组件PlayerController，编写脚本使player能够上下左右移动。 为player制作等待动画idle animation，包括四个方向，其中左右通过flip属性来完成镜像。在animation/player中自定义一个blend tree,目的是为了混合四个方向的动画。 2.绘制场景","link":"/2021/06/14/unity-learn-ruby/"},{"title":"Unity_Timeline","text":"2021.063D基础：Roll a Ball (siki学院) 2D案例：坦克大战 (siki学院)，Ruby’s Adventure(unity官方), Pixel Adventure(像素忍者) 2021.07How to make a 2D Game (Brackeys) C# Intermediate Unity Tutorials (GameDevHQ) √ C# 中级教程 (Unity官方) 2D Game Kit (Unity Asset Store) (玩了一遍) 图解算法数据结构(leetcode) 初级算法(leetcode) 先比较两边的代码，然后进行移植(2d movement/animator √) How to make a Tower Defense Game (Brackeys 01-12) 2021.08How to make a Tower Defense Game (Brackeys 13-23) 找一些中级C#教程看 找一些中型项目的教程 从8月开始，不再是跟着视频手把手的做，尽量做到看一遍视频，然后自己遍动脑，独立完成。 C语言写的学生管理系统。 遇到的问题How to make a Tower Defense Game (E08 SHOP) 1：19 关于pixel perfect的用法","link":"/2021/07/02/unity-study-timeline/"},{"title":"unity学习笔记01","text":"内容整理参考B站UP主 yu_zhen基本介绍新建的项目默认包括一个主相机和一个光源 在空白处右键添加新的元素：3D Object-Terrain 是地形，在Scene中显示为一个平面3D Object-Tube 是立方体Creat Empty是空对象，我感觉类似编程思想中的object 看官方文档没搞懂的地方：游戏对象的可拾取性（在hierarchy窗口中）正交视图是干什么用的（一般情况下用的都是Perspective透视视图）pivot和center的关系:https://blog.csdn.net/weixin_41319239/article/details/93681860烘培光照贴图是什么意思：https://docs.unity.cn/cn/2020.3/Manual/MultiSceneEditing.html多场景编辑有什么用关于2D关节组件Joint2D，2D效应器组件Effector2D的应用案例在3DObject中有一个布娃娃Ragdoll","link":"/2021/06/02/unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"},{"title":"How to make a 2D Game","text":"2D Movement in Unity&lt;关于2D碰撞的一些优化设置&gt; Rigidbody2D-Collision Detection Discrete GameObjects with Rigidbody 2Ds and Collider 2Ds can overlap or pass through each other during a physics update Continuous GameObjects with Rigidbody 2Ds and Collider 2Ds do not pass through each other during an update Physics Material 2D Friction Bounciness 12345678910111213141516171819202122// CharacterController2D.csFixedUpdate(){ 判断角色是否落地： 在角色脚下新建一个EmptyObject, 通过Physics2D.OverlapCircleAll方法检测有什么跟角色的脚底发生了碰撞。 如果发生碰撞的不是gameObject, 那么认定角色在地面上。}Move(){ 如果角色在蹲着，判断是否可以站起来： 可以控制player的条件是：player在地面上或者允许player在空中移动 如果player在蹲着，那么降低移动速度}Flip(){ 通过让palyer的localscale的X取负数来实现左右朝向的反转}","link":"/2021/07/02/how-to-make-2D-game/"},{"title":"做过的梦","text":"1.杀人事件 20210619我，子城，张哲，周宇去给一个小女孩过生日。最后我们五个人要开车离开，开车到一半的时候，有人说忘了东西要回去一趟，于是我们都跟着回去了，下车后女孩跑进了教堂，我和子城追了过去，教堂左边右边都是双层的大走廊，我和子城去了左边找小女孩，张哲和周宇去了右边。后来周宇在右边的二楼发现了小女孩的尸体，胸口被贯穿，当时貌似只有张哲不在场，因此我一直怀疑张哲。不过警察却认为这是一场意外。后面的内容记不清了。 2.郑娥事件 20210621某个不露脸的主播在一次直播中与一名黑丝女子xxoo，期间被观众捕捉到了男主播的正脸和女子的名字叫郑娥。很快有记者把这个名字锁定在了一家妇科医院。记者通过看病为由进入医院和郑娥见面并确定了就是此人。随后记者在她下班后一路尾随到了她家。连门牌号都确定了，却不明白为什么跟踪的过程为什么这么顺利。他们后来调查了解到郑娥因为行为不检点，经常利用职务之便给自己做堕胎手术，先前提到的主播也只不过是她的众多炮友中的一个。","link":"/2021/06/19/%E5%81%9A%E8%BF%87%E7%9A%84%E6%A2%A6/"},{"title":"用hexo搭建个人博客的过程记录","text":"这是第一篇博客，主要记录用hexo搭建的过程和熟悉markdown的语法 1.包的安装和初始化 安装node.js 通过cmd打开windows的终端安装镜像包和hexo包 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org $ cnpm install -g hexo-cli 在C盘下新建文件夹hexo_blog/ 回到终端初始化博客 1$ hexo init 至此windows终端上的操作结束，博客文章默认保存在hexo_blog/source/_posts在里面也可以看到自带的hello-world.md 2.部署远端仓库 在github中新建仓库名qifeng1994.github.io 在git bash中安装hexo插件 1$ cnpm install --save hexo-deployer-git 用编辑器打开hexo_blog/_config.yml在 # Deployment 的下面修改1234deploy:type: gitrepo: https://github.com/qifeng1994/qifeng1994.github.io.gitbranch: master 回到git bash在hexo_blog/ 把本地仓库部署到github上1$ hexo d 3.额外的修改 为了解决插入图片后不显示的问题： 修改_config.yml中设置 1234post_asset_folder: true # URL url: https://qifeng1994.github.io 安装hexo额外的图片路径转换插件1$ cnpm install hexo-asset-image –save 修改代码/node_modules/hexo-asset-image/index.js 4.尝试写第一篇博客 新建一篇博客 1$ hexo n &quot;文件名&quot; 注意这里的文件名就是md的文件名，而这篇博客具体的标题可以在md里面修改，在hexo_blog/source/_posts下生成了同名的文件夹用于存放图片 由于安装了插件，插入图片时不采用md的语法1{% asset_img man.png 图片的说明 %} 在本地写好博客之后，可以先在本地浏览器预览1$ hexo s 生成静态文件1$ hexo g 部署到远端1$ hexo d 最下面是一个插入图片的例子 目前写markdown存在的问题 带后缀的句子会被识别为超链接 如何让插入的图片靠左边显示 目前遇到的坑 插入图片的时候后缀是大小写敏感的，比如，如果一个图片叫man.PNG，那么你插入的时候如果用 1{% asset_img man.png %} 就会显示不出来 hexo d 部署后个人主页404的原因 我之前把仓库的权限改成了privite,后来发现有一种说法是github如果想做个人主页的话，仓库必须要是public才行，然后尝试重新部署即可：hexo clean, hexo g, hexo d","link":"/2021/08/26/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"title":"unreal dev","text":"我的第一个游戏开发日志2022/04/04制作第一个关卡：一个房间，包括一个落地窗，床，桌子，卫生间，门，如果可以的话加上一个窗帘 首先复习一下LightingShadow这个快速指南。然后用BSP Brash绘制房间的边界，再加入家具(需要参考油管bsp to mesh的视频) 2022/04/06重新建了一个level1，这次直接用mesh来搭房子，门框和窗户框是通过BSP brush来做的，因为需要剔除门的空间。然后把brush生成mesh，再添加材质。 测试遇到的问题 从brush生成的mesh不受光照影响，也就是说材质没有被反射，玩家视角看到的是黑色的。 需要做的改动如图，光照贴图分辨率参考其他的墙mesh设置为128，光照贴图坐标索引设为1。 当前的mesh默认是没有碰撞的，也就是说玩家会穿墙，对于窗户框来说，添加盒体简化碰撞(当前不希望玩家能穿过窗户)，而对于门框来说，可以通过添加凸包碰撞来自动设置，但是精度有限。 通过添加盒体碰撞然后自定义范围来规划碰撞体积。效果如图 2022/04/07今天想做游戏的开头，玩家躺在床上的视角，遇到了问题。 先把玩家放在床上 然后简化了床的碰撞盒 但是游戏运行的时候，玩家无法躺在床上 但是如果勾选胶囊物理效果就可以躺下 或者把胶囊碰撞体缩小 还有一种我觉得比较好的解决方法是把默认的胶囊缩小，然后再新建一个和人等大的胶囊 之所以要重新添加一个胶囊是因为我怀疑原来的胶囊碰撞体根本无法旋转 还有一个原因我觉得是本身这个场景就不应该用character而是应该用pawn 今天还看了官方的第三人称教程 到12P，还有几个设置没太搞懂，先截图记录下来。均取自character蓝图类。 类默认设置–Pawn–使用控制器旋转Yaw 移动组件–角色移动(旋转设置)–使用控制器所需的旋转/将旋转朝向运动 2022/04/08明天计划先把第三方教程过一遍，然后找mixamo导入unreal和动画相关的教程，第一场景新建一个pawn类来做。 第三人称游戏的教程没有过完，mixamo导入unreal实现了，但还有缺陷。今天没有做实际的游戏开发。 2022/04/09计划看官方骨骼的视频，然后学习蒙皮权重相关的知识。 2022/04/102022/04/11游戏内摄像机的切换方法 案例参考官方文档 ，思路类似actor之间的通信，把Character蓝图的PlayerController组件里的的相机做替换。 2022/04/12限制摄像机转动角度的方法，关键词 camera rotation limit 油管教程就不贴了，后来看到了一个比较简单的方法 虽然不清楚对后续开发是否有影响，反正目前想要达成的目的算是实现了。没想到还有这么简单的方法。 dialog 开发过程中的一些技术总结关于玩家摄像机镜头的调整 UE4的第一人称模板中，player是由手臂和枪组成的，与相机绑定。 在相机的细节中勾选使用Pawn控制旋转 这种相机设置的效果就是相机始终和枪口在一个方向。 但是像吃鸡这样的第一人称游戏中，低头会看到玩家自己的躯干。 为了实现这样的效果，可以修改第三人称模板来实现。 方法参考油管视频 在第三人称的模板中把相机挂在弹簧臂下面，弹簧臂像自拍杆一样与actor保持固定距离。 同样在相机的细节中勾选了使用Pawn控制旋转 。 相机的修改如下：删除弹簧臂，然后把相机挂载在mesh下面。在插槽中选择head，然后调整相机的transform。可以修改FOV，把相机下移到胸口附近，这样可以在低头时看到手。 然后在相机的设置中勾选使用Pawn控制旋转，勾选后表示可以通过鼠标来旋转相机，但是会出现旋转过头的现象，玩家的头是无法旋转360度的。 造成这种问题的原因可以理解为相机在旋转的时候，玩家并没有旋转，如果玩家可以跟着旋转的话，相机的角度就不会过大了。 在最上一层的actor设置中勾选使用控制器旋转Yaw 最后游戏中低头的效果，目前稍微有点穿模。 坐标系相关的总结直接说结论，坐标系的方向遵循笛卡尔左手坐标系。 首先这是UE4空白项目的世界坐标系 在维基百科中，笛卡尔坐标系分为左手和右手两种 由图可知UE4是遵循左手坐标系，而XYZ的顺序也是按照自然法则的顺序来命名的。 最后是关于旋转的定义，三个轴的旋转对应飞机的航偏轴，直接上图 唯一需要记忆的是XYZ对应的旋转顺序是Roll Pitch Yaw X Y Z R G B 大拇指 食指 中指 Roll Pitch Yaw 关于蓝图的迁移记录蓝图迁移的方法是因为考虑到以后会经常性的把其他项目的蓝图整合到自己的游戏里面。如果能够顺利迁移的话可以提高开发的效率。 这次迁移的案例是把第三人称模板里的角色蓝图迁移到一个新的空白项目中。 这个蓝图的父类是character，蓝图中使用了UE自带的mesh人物，绑定了默认的动画，定义了基本的移动。 从迁移的内容中可以看到相互绑定的关系。(所以在资源迁移的时候并不是单单的把这一个蓝图文件拷贝过去) 可以看到实际迁移的资产包括动画，材质，纹理，男女两个mesh，和最开始介绍的蓝图 (如果迁移的是同名游戏模式，则蓝图的最下面还包括了游戏模式蓝图) 把这些内容迁移到一个新建的空白项目中，需要迁移到content/ 的目录下 把蓝图拖到游戏场景中发现并不能像第三人称模板一样运行，接下来设置其他的地方 将拖入场景的ThirdPersonCharacter的pawn改成玩家0，这样游戏开始时默认的视角就不是player start了 新建一个game mode，把默认pawn改成ThirdPersonCharacter 在项目设置–地图和模式–默认游戏模式 改为刚才新建的名字 在项目设置–引擎–输入 中导入第三人称模板的配置文件 回到游戏中可以发现角色被完整的移植了过来 Actor通信的方法**通过蓝图实现Actor通信的方法，参考自 官方文档 ** Actor之间的通信可以理解为玩家按下按键让灯亮或者是玩家靠近一个门，门自动打开。 直接通信 在玩家蓝图中新建一个公开变量，变量类型是灯的蓝图类，通过直接访问灯的组件来控制的亮灭 这种方法最后需要在游戏场景中的玩家设置中指定lamp reference是谁，这里指定的是一个实例。 类型转换 用cast to来判断是否是目标actor，这个案例中玩家靠近灯后灯会灭，远离后灯会亮。 给玩家添加一个球形碰撞检测，分别在重叠和离开的时候设置灯的亮灭。 图中的两个事件是右键Sphere选择的，这种方法相比第一种不需要特殊指定，也就是说在地图里放很多Blueprint Ceiling Light都可以与之互动。 接口 这个案例中，玩家靠近灯时灯灭，远离时灯亮。通过接口实现的好处就是接口可以重用，其他的类也可以使用接口，只不过实现的具体方法不同。 首先新建一个蓝图接口，在接口中定义Turn On和Turn Off两个函数。 玩家与actor重叠时调用接口。 在灯的蓝图中先勾选实现接口 然后实现接口中的函数 事件分发器 在这个案例中，玩家每当靠近或远离灯时，不仅会让灯亮灭，还会让触发一个爆炸特效。 事件分发可以理解为视频网站更新视频，即 创建一个视频频道 有观众订阅这个频道 这个频道发布新视频 订阅了这个频道的观众会受到新视频的通知 为了方便把玩家当作是视频频道，而玩家每次与灯触发的事件视作发布一个新的视频，即第一步和第三步 灯和爆炸特效为了订阅这个频道需要创建一个玩家类的公开变量，这里就叫做Subscribe。对应第二步和第四步。 通过C++实现Actor通信 直接通信 玩家按F键 灯亮 创建Actor类来定义灯，头文件中添加场景组件，点光源组件，静态网格组件，实现灯开关的自定义函数和一些数据成员，然后再构造函数中对这些成员进行定义。—-自此完成了对CeilingLight类的定义 12//CeilingLight.cppvoid ACeilingLight::TurnOffLight() {...} //开关函数 基于这个C++类创建蓝图类，给蓝图类添加mesh素材。然后把蓝图类拖到场景中实例化，完成了从类到对象的过程。 进入玩家类的头文件 123456//Character.h//有什么办法可以按键后让场景中的所有灯都亮灭？？protected: UPROPERTY(EditInstanceOnly, BlueprintReadWrite) class ACeilingLight* CeilingLightToToggle; //继承类 void ToggleCeilingLight(); //开关函数 定义成员函数 12345678//Character.cppvoid ACharacter::ToggleCeilingLight(){ if (CeilingLightToToggle) { CeilingLightToToggle-&gt;TurnOffLight(); //通过指向对象的指针来调用函数 }} 定义交互方式 123456//Character.cppACharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent){ ... PlayerInputComponent-&gt;BindAction(&quot;Use&quot;, IE_Pressed, this, &amp;ACharacter::ToggleCeilingLight); //当按键时调用开关函数} 目前已经在玩家的类中继承了一个灯的类，如果想通过按键实现让灯亮灭还要指定这个灯（对象）是谁 类型转换 玩家靠近时灯亮，远离时灯灭 灯的设置不变 玩家类中添加用于碰撞检测的球和碰撞事件 12345//Character.h 这次不需要继承ceilinglighting类了protected: virtual void NotifyActorBeginOverlap(AActor* OtherActor); virtual void NotifyActorEndOverlap(AActor* OtherActor); class USphereComponent* SphereComp; //球体组件 实现成员函数 12345678910111213141516//Character.cpp//如果类型转换成功，则直接调用成员函数void ACharacter::NotifyActorBeginOverlap(AActor* OtherActor){ if (ACeilingLight* ActorCheck = Cast&lt;ACeilingLight&gt;(OtherActor)) { ActorCheck-&gt;TurnOffLight(); }}void ACharacter::NotifyActorEndOverlap(AActor* OtherActor){ if (ACeilingLight* ActorCheck = Cast&lt;ACeilingLight&gt;(OtherActor)) { ActorCheck-&gt;TurnOffLight(); }} 可以看到这个案例中，类型转换比直接通信相比，首先玩家类不需要去继承灯的类了，因此也不需要去指定游戏场景中的灯对象。其次是可以在游戏场景中放置多个灯，都可以触发亮灭的逻辑。 接口 初始化接口 1234//InteractInterface.hpublic: UFUNCTION() virtual void OnInteract() = 0; //纯虚函数 在灯的头文件中声明接口 1234567//CeilingLight.hUCLASS() class ProjectName_API ACeilingLight : public AActor, public IInteractInterface //多重继承 { public: virtual void OnInteract(); } 实现接口 12345//CeilingLight.cppvoid ACeilingLight::OnInteract(){ TurnOffLight(); //这个函数跟之前介绍的一样} 在玩家类中调用接口 12345678910111213141516//Character.cpp//如果碰撞体实现了接口，那么调用它的接口的函数void ACharacter::NotifyActorBeginOverlap(AActor* OtherActor){ if (IInteractInterface* ActorCheck = Cast&lt;IInteractInterface&gt;(OtherActor)) { ActorCheck-&gt;OnInteract(); }}void ACharacter::NotifyActorEndOverlap(AActor* OtherActor){ if (IInteractInterface* ActorCheck = Cast&lt;IInteractInterface&gt;(OtherActor)) { ActorCheck-&gt;OnInteract(); }} 事件分发器 (运行游戏时会崩溃，编译没有问题) 假如玩家触发了A事件，那么绑定过A事件的actor会调用自己的函数。可以把A事件独立出来作为一个actor类，因此玩家不需要主动进行碰撞检测。 玩家类还原为默认，不需要做修改。 创建一个盒体类用于声明委托 123456789//EventActor.hDECLARE_DELEGATE(FOnBossDiedDelegate);...UPROPERTY(EditInstanceOnly, BlueprintReadWrite) class UBoxComponent* BoxComp; //盒体组件virtual void NotifyActorBeginOverlap(AActor* OtherActor); //用于碰撞检测FOnBossDiedDelegate OnBossDied; //这种写法好像类和对象UFUNCTION() void HandleBossDiedEvent(); // 12345678910//EventActor.cppvoid AEventActor::NotifyActorBeginOverlap(AActor* OtherActor){ HandleBossDiedEvent(); //当有actor碰到盒体时，调用事件}void AEventActor::HandleBossDiedEvent(){ OnBossDied.ExecuteIfBound(); //这个事件激活了委托，那么绑定了OnBossDied的类都会有所反应！} 灯的类中添加对委托的引用 123//CeilingLight.hUPROPERTY(EditInstanceOnly, BlueprintReadWrite) class AEventActor* EventActorReference; 12//CeilingLight.cpp 这句话会造成程序崩溃EventActorReference-&gt;OnBossDied.BindUObject(this, &amp;ACeilingLight::TurnOffLight); //灯的开关函数绑定OnBossDied 在关卡蓝图种实现actor通信 案例：玩家靠近碰撞盒后灯亮 制作UE插件的方法 使用BSP Brush的心得首先关于Brush是干什么的？ 上图是从BSP生成的mesh，从左到右依次是默认的cube，将笔刷的长度缩小一倍，将Transform缩小一倍而生成的，但是在引用相同的材质时可以看到，通过Transform缩小一倍的mesh材质也被压缩了。 而把mesh做替换后，生成的大小是一样的。也就是说mesh是不受影响的。 由此可以联想到在做建筑物的建模时， 如果首先通过放大笔刷来构图(全部基于1立方的cube)，那么接下来在同位置替换mesh的时候与构图定义的尺寸没有直接关系 如果想直接使用BSP的话，例如地板，只给一面上材质： 所以理想的工作流程应该是先用BSP做基础建模，但是定好了模型的尺寸，然后在根据限定的尺寸去做具体的模型 动画系统学习笔记2022/04/08 直接学习过动画混合和序列相关的知识，后来发现好像动画系统是一个很大的分支。所以准备先过一下，如果有可以上手的案例顺便做一做。 主要看的是 骨架网格体动画系统 角色设置 的流程是 找到合适的骨架网格体和对应的动画 导入FBX模型，如果不匹配现有的骨骼，则生成一个新的骨骼。 创建玩家控制器脚本或蓝图来处理来自玩家的输入 为角色或Pawn创建一个蓝图或脚本或蓝图来解析输入并控制角色的实际移动（不是骨架动画） 为角色构造动画蓝图 创建一个使用自定义玩家控制器和任何其他自定义脚本资产的游戏模式脚本或蓝图 Mixamo上的资源如何用到UE4里面Mixamo上主要有两种资源，character和animation 目标是让Mixamo上的character能替换到第三人称模板的小白人上去，然后给他添加动画(这个动画最好是能兼容Mixamo上的动画和EPIC商城的动画) 直接把character (FBX)导入UE项目中，如果在导入选项中指定UE默认的骨骼，后面可能会有问题，如果不指定的话会自己生成一个新的骨骼。FBX会被拆分，主要是图中的四大项 这样虽然可以成功导入，但是如果想继续给添加动画的话，感觉无法和UE默认的资源兼容，因此还需要继续从Mixamo上下载相匹配的动画。我觉得这样有可能会无法和虚幻商城的动画包相匹配。 直接把animation导入UE项目中，这样做的初衷是想给UE添加新的动画，我在网上发现了一个转换工具 Mixamo Converter ，这个软件的原理是预先准备了一个能和Mixamo上的character相匹配的UE模型，然后传上去，再下载想要的animation，然后把animation在软件中转化一下就可以顺利导入到UE中，导入后的动画用的是还是原来小白人的骨骼和mesh。 这种方法适合给小白人添加新的动画 利用 骨骼重定向 的方法，可以实现1：把新的角色和动画导入 2：把新的动画匹配到UE的小人上。 重定向的具体设置： 导入后角色的头发不能正常显示，修改材质 总结一下目前用到的几个角色资源包 AnimStarterPack 官方的动画包 ​ 导入后包括动画和mesh和骨骼，mesh和骨骼跟默认的小白人一样，但是如果想把动画添加到第三人称模板上，不能直接引用，可以通过先导出FBX再导入，导入的时候绑定到第三人称模板的骨骼上就可以使用了。 Scanned3DPeoplePack 商店免费资源 实际能操控的mesh有6个，骨骼跟小白人一样，但是想把现成的mesh替换掉模板的小白人实现小白人的移动动画是不行的，因为绑定的骨骼路径不同。因此需要更改绑定。 以这个mesh为例，右键，骨骼–指定骨骼，然后选择模板的骨骼 可以看到正因为mesh的骨骼是一样的，所以可以直接替换绑定 来到ThirdPersonCharacter蓝图，替换mesh 可以看到替换完的mesh还可以使用模板的动画，算是完美兼容。而没有绑定新骨骼的男性mesh只能显示出T型模型，并不会使用动画。 BattleWizardPolyart 商城免费资源 骨骼与默认的小白人相比有拓展。 如果想把套在小白人上，方法同2，但是需要注意 然后如果还想把小魔法师的动画也移植过去，可以先做骨骼重定向， 例如 从缩略图可以看到腿部是 有问题的 实际在游戏中的表现，右腿出现了偏移。 这里的解决方法应该需要用到 动画重定位 (为了把动画重定位，其实修改的是骨骼树) 在这个例子中我主要修改了 这里其实是把第三人称模板的默认骨骼设置修改了 实际游戏中比之前下降了一点，但不够完美 这部分的讲解视频可以参考官方油管 Mixamo 重头戏来了 首先要明确Mixamo上的骨骼和Mannequin是不一样的，也就是说不能像之前的三个例子一样直接把模型移植过去。 这个时候需要用到 骨骼重定向 重定向设置完后可以对动画进行双向导入。也就是说前面三个案例中的动画，可以通过 重定向动画资产 生成新的拷贝给Mixamo模型去用，或者是把Mixamo上的各种动画拿给能兼容Mannequin骨骼的模型去用(这就是之前介绍过的一个convert软件) 关于骨骼重定向的讲解视频可以参考官方油管 和 Smart Poly 的视频 对话系统对话系统参考油管教程 目前先粗略梳理一下开发流程，后面会添加详细的说明 这个对话系统基于碰撞和按键交互触发。NPC与玩家发生碰撞后按F进入对话，鼠标选择对话选项。 各蓝图类中的Event Dispatchers情况总览 DialogComponent : 绑定 OnExit事件(DialogWidget) DialogWidget : OnExit分发事件, OnSpeakFinish分发事件, OnReplyFinish分发事件, OnMouseButtonDown(Override) 绑定OnClicked事件(DialogReplyObject) Speak : 绑定OnSpeakFinish事件 Reply : 绑定OnReplyFinish事件 DialogEntry_BP : 实现接口UserObjectListEntry DialogReplyObject : OnClicked分发事件 准备工作： 用于交互的接口类 Interaction，实现Interaction接口的组件DialogComponent，玩家添加球型碰撞器InteractionSphere 玩家与NPC碰撞时(将实现了Interaction接口的actor储存到数组中)/离开时(移除数组元素) ThirdPersonCharacter 当按下交互按键时，选择与玩家最近的NPC调用Interaction接口的函数OnInteraction() DialogComponent 响应接口的调用 Create Widget, Add to Viewport, Set Input Mode UI Only DialogComponent 运行BehaviorTree, Blackboard DialogTree Key:DialogWidget(在DialogComponent中赋值), ReplyIndex 序列的第一个任务Speak，代表NPC要说的话 Speak 执行任务 以text为参数调用Speak事件(DialogWidget) DialogWidget 显示SpeakBox隐藏ReplyBox DialogWidget 鼠标按下后从NPC的话切换到玩家的话（SPEAK任务结束，进入下一个REPLY任务） 函数OnMouseButtonDown Speak 由于Speak绑定了OnSpeakFinish事件， 结束任务，进入行为树序列的下一个任务 Reply 任务开始执行 传递reply text参数调用Reply事件 DialogWidget Reply事件把数组元素构建为对象，存入reply的对话列表中 显示ReplyBox隐藏SpeakBox DialogEntry_BP 响应接口的调用，把行为树中的对话内容赋值给当前的widget DialogEntry_BP reply被点击后，调用OnClicked事件（DialogReplyObject） DialogWidget 绑定了Onclicked事件，调用OnReplyFinished事件 Reply 绑定了OnReplyFinish事件，任务结束，根据玩家选择的对话选项进入序列的下一个任务 Exit 这里假设玩家对话选项选择完后，NPC再说一句话 然后触发结束任务 DialogComponent 绑定了OnExit事件，Set Input Mode Game Only, Stop Logic (Behavior Tree), Remove widget from Parent 发现的问题：貌似教程里提到的一段节点没有用到？ DialogWidget 可能会用到的插件 Fade Objects：顾名思义是一个组件，可以改变第三人称游戏中相机和玩家之间的物体的材质实现透明的效果（本体是C++写的，但是感觉上比较简单，应该可以研究一下） AGR：（好像是一个管理系统，没搞懂有什么用） Async Loading Screen：应该是在读取下一个level时候用的过场动画插件 Cesium：（不知道是什么东西） Directional &amp; Planet Gravity：一个改变重力方向的插件 Easy Quests：任务系统，基于蓝图开发的组件（感觉可以研究一下） GOAP NPC：可以给NPC添加AI逻辑？ Graph Formatter：一个理线的插件 Journeyman’s Minimap：小地图插件 Physical Layout Tool ：可以给mesh附加物理效果(重力) Prefabricator：把素材规划成一个prefab，然后随机的生成，可以实时生成 Procedural Building Generator：一个用于城市建模的蓝图，提供了一些选项方便快速建模（感觉有机会用到） ProInstance Tools Plugin：同样是建模插件，特点是批量生成和管理 Root Motion Guide：（动画相关的插件，没搞懂，但是貌似教程很详细） UI Navigation：一个做游戏菜单的框架（感觉后面会用到） Weather System：国人做的，不知道会不会用到 Blockout Tools ：提供一些现成的mesh(现在是收费的了) SuperGrid Starter pack ：这是一个工程文件，里面有提供现成的mesh，方便创建关卡的原型 插件下载后保存在engine/marketplace下面。可以看到部分源码？ 开发中还未解决的问题 按键弹出UI这样的key press event写到哪里比较好？玩家蓝图？关卡蓝图？还是在控件蓝图里写？ 案例研究ContentExampleGeometry 1.2 依次把1 2 3的盒体笔刷排序到最后一项 1.3 没懂有什么用 1.6 非常巧妙的建模（应该用了大量的sub盒体） FBX 1.2 LOD细节层级，一个非常神奇的例子！（镜头拉远后会变更mesh的材质） 1.3 计算法线（Calculate Normals） 导入法线（Import Normals） 都是什么东西？？ 1.7 如何把cube变成骨骼体？再添加变形动画？ Navmesh 1.1 让AI通过导航跨过障碍物，利用simple move to location节点。（如果是pawn类的话貌似不能跨过障碍物，但是可以在导航点之间移动） 1.2 利用导航链接代理NavLinkProxy来实现翻越障碍物（自己做案例的时候不能100%成功） 1.3 （没懂和1.1的区别） Math 1.2 利用time的sin的abs来作为材质（材质中用到了lerp函数，但是向量的算法没搞懂） 1.3 Frac函数的用法 1.4 … 2.9 让物体旋转朝向玩家的例子（复现成功） 2.14 向量点积 dot product 就是向量的乘积 2.17 （材质的案例，没看懂） 2.18 向量积（不知道有什么用） 2.20 （材质函数没搞懂） Animation 1.3 （尝试做一个用鼠标拖动的滑块）（还没搞懂里面的函数，有没找到的变量名hovered） （妈的动画部分东西好多） Blueprints_Overview 1.4 通过构造函数为蓝图类添加组件（感觉没什么用） 1.5 通过构造函数创建动态材质（三个节点） 1.7 Blueprints_Advanced 1.1 在一个区域内随机生成静态网格体（复现成功） 1.2 （也是自动生成，但是没看懂） 1.3 （也是自动生成，但是感觉可以复现出来） 1.4 聚光灯的材质很有朦胧的感觉，说不定可以用来挡镜头 2.1 利用timeline改变球的位置和scale来实现弹球的效果 2.2 摄像机追踪人（跳过） 2.3 接口实现，踩下按钮，让其他物体旋转（复现成功） 2.4 开门关门（感觉可以复现） 2.5 父子类蓝图（没看懂）玩家在吃道具的时候有一个吸附过程 （真牛啊） Blueprint Communication 1.1 最简单的通过自定义事件触发开关灯，这里灯的亮灭经过了一个timeline。按钮在被按下时材质会发生变化 1.2 实际上是三个actor之间的通信，比较有新意的是，灯的亮度通过电池的容量调节。电池类中定义了与按钮的交互和电池的电量，灯类中定义了与电池的交互和亮灭的细节 1.3 1.4 按钮类通过Get all actors of class 来让一群灯亮，灯类通过set play rate实现随机timeline看起来不同灯有不同的闪烁 2.1 基本的事件分发器，但是通过关卡蓝图实现的中转 2.3 炸弹爆炸，要搞懂这个过程的状态转移 3.2 接口三个拉杆的案例 Blueprint_Input 有三个小游戏案例，首先实现了玩家控制器的切换功能 （虽然还没细看，但是感觉里面的游戏逻辑值得研究） Blueprint_HUD 这个吃道具的案例用到了很多功能性类，比如game mode，hud，level bp，controller bp 虽然貌似hud已经比较老了，但是有时间可以做一个框架梳理 Blueprint_Splines 1.3 不知道有什么用，通过splinemesh组件拉伸一个管道，但是不能像spline组件一样派生多个拐点 （向量的计算没看懂） 2.2 动态添加spline，实现了随风摆动的灯笼（详细没看） 2.3 树枝生长的动画，用到了很多和spline相关的节点 2.4 模拟鱼的运动（这个太牛逼了，感觉看会就能出师了） Physics 1.1 给mesh勾选movable和simulate physics来添加物理效果（玩家的抓取系统看起来很复杂 玩家蓝图中定义了一个grabb函数，和官方教程的案例有相似的地方，不过官方教程把抓取做成了一个组件） 1.2 给骨架mesh添加物理，实现了像人类一败涂地的效果 StaticMesh 1.3 为什么！！UV通道是什么东西 官方文档学习笔记材质节点的说明","link":"/2022/06/07/unreal-dev/"}],"tags":[],"categories":[]}